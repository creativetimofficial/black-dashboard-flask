{"version":3,"sources":["src/common.browser/ReplayableAudioNode.ts"],"names":[],"mappings":"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","file":"ReplayableAudioNode.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\n// eslint-disable-next-line max-classes-per-file\r\nimport {\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n} from \"../common/Exports\";\r\n\r\nexport class ReplayableAudioNode implements IAudioStreamNode {\r\n    private privAudioNode: IAudioStreamNode;\r\n    private privBytesPerSecond: number;\r\n    private privBuffers: BufferEntry[] = [];\r\n    private privReplayOffset: number = 0;\r\n    private privLastShrinkOffset: number = 0;\r\n    private privBufferStartOffset: number = 0;\r\n    private privBufferSerial: number = 0;\r\n    private privBufferedBytes: number = 0;\r\n    private privReplay: boolean = false;\r\n    private privLastChunkAcquiredTime: number = 0;\r\n\r\n    public constructor(audioSource: IAudioStreamNode, bytesPerSecond: number) {\r\n        this.privAudioNode = audioSource;\r\n        this.privBytesPerSecond = bytesPerSecond;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privAudioNode.id();\r\n    }\r\n\r\n    // Reads and returns the next chunk of audio buffer.\r\n    // If replay of existing buffers are needed, read() will first seek and replay\r\n    // existing content, and upoin completion it will read new content from the underlying\r\n    // audio node, saving that content into the replayable buffers.\r\n    public read(): Promise<IStreamChunk<ArrayBuffer>> {\r\n        // if there is a replay request to honor.\r\n        if (!!this.privReplay && this.privBuffers.length !== 0) {\r\n            // Find the start point in the buffers.\r\n            // Offsets are in 100ns increments.\r\n            // So how many bytes do we need to seek to get the right offset?\r\n            const offsetToSeek: number = this.privReplayOffset - this.privBufferStartOffset;\r\n\r\n            let bytesToSeek: number = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\r\n            if (0 !== (bytesToSeek % 2)) {\r\n                bytesToSeek++;\r\n            }\r\n\r\n            let i: number = 0;\r\n\r\n            while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\r\n                bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\r\n            }\r\n\r\n            if (i < this.privBuffers.length) {\r\n                const retVal: ArrayBuffer = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\r\n\r\n                this.privReplayOffset += (retVal.byteLength / this.privBytesPerSecond) * 1e+7;\r\n\r\n                // If we've reached the end of the buffers, stop replaying.\r\n                if (i === this.privBuffers.length - 1) {\r\n                    this.privReplay = false;\r\n                }\r\n\r\n                return Promise.resolve<IStreamChunk<ArrayBuffer>>({\r\n                    buffer: retVal,\r\n                    isEnd: false,\r\n                    timeReceived: this.privBuffers[i].chunk.timeReceived,\r\n                });\r\n            }\r\n        }\r\n\r\n        return this.privAudioNode.read()\r\n            .then((result: IStreamChunk<ArrayBuffer>): IStreamChunk<ArrayBuffer> => {\r\n                if (result && result.buffer) {\r\n                    this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));\r\n                    this.privBufferedBytes += result.buffer.byteLength;\r\n                }\r\n                return result;\r\n            });\r\n    }\r\n\r\n    public detach(): Promise<void> {\r\n        this.privBuffers = undefined;\r\n        return this.privAudioNode.detach();\r\n    }\r\n\r\n    public replay(): void {\r\n        if (this.privBuffers && 0 !== this.privBuffers.length) {\r\n            this.privReplay = true;\r\n            this.privReplayOffset = this.privLastShrinkOffset;\r\n        }\r\n    }\r\n\r\n    // Shrinks the existing audio buffers to start at the new offset, or at the\r\n    // beginning of the buffer closest to the requested offset.\r\n    // A replay request will start from the last shrink point.\r\n    public shrinkBuffers(offset: number): void {\r\n        if (this.privBuffers === undefined || this.privBuffers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.privLastShrinkOffset = offset;\r\n\r\n        // Find the start point in the buffers.\r\n        // Offsets are in 100ns increments.\r\n        // So how many bytes do we need to seek to get the right offset?\r\n        const offsetToSeek: number = offset - this.privBufferStartOffset;\r\n\r\n        let bytesToSeek: number = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\r\n\r\n        let i: number = 0;\r\n\r\n        while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\r\n            bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\r\n        }\r\n        this.privBufferStartOffset = Math.round(offset - ((bytesToSeek / this.privBytesPerSecond) * 1e+7));\r\n        this.privBuffers = this.privBuffers.slice(i);\r\n    }\r\n\r\n    // Finds the time a buffer of audio was first seen by offset.\r\n    public findTimeAtOffset(offset: number): number {\r\n        if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\r\n            return 0;\r\n        }\r\n\r\n        for (const value of this.privBuffers) {\r\n            const startOffset: number = (value.byteOffset / this.privBytesPerSecond) * 1e7;\r\n            const endOffset: number = startOffset + ((value.chunk.buffer.byteLength / this.privBytesPerSecond) * 1e7);\r\n\r\n            if (offset >= startOffset && offset <= endOffset) {\r\n                return value.chunk.timeReceived;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n\r\n// Primary use of this class is to help debugging problems with the replay\r\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\r\n// the ArrayBuffer directly.\r\nclass BufferEntry {\r\n    public chunk: IStreamChunk<ArrayBuffer>;\r\n    public serial: number;\r\n    public byteOffset: number;\r\n\r\n    public constructor(chunk: IStreamChunk<ArrayBuffer>, serial: number, byteOffset: number) {\r\n        this.chunk = chunk;\r\n        this.serial = serial;\r\n        this.byteOffset = byteOffset;\r\n    }\r\n}\r\n"]}