{"version":3,"sources":["src/sdk/ConnectionMessage.ts"],"names":[],"mappings":"AAOA,OAAO,EACH,iBAAiB,IAAI,oBAAoB,EAE5C,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EACH,kBAAkB,EACrB,MAAM,sBAAsB,CAAC;AAG9B;;;;;;;GAOG;AACH,8BAAsB,iBAAiB;IACnC;;OAEG;IACH,aAAoB,IAAI,IAAI,MAAM,CAAC;IAEnC;;;OAGG;IACH,aAAoB,aAAa,IAAI,OAAO,CAAC;IAE7C;;;OAGG;IACH,aAAoB,eAAe,IAAI,OAAO,CAAC;IAE/C;;;;OAIG;IACH,aAAoB,WAAW,IAAI,MAAM,CAAC;IAE1C;;OAEG;IACH,aAAoB,aAAa,IAAI,WAAW,CAAC;IAEjD;;;OAGG;IACH,aAAoB,UAAU,IAAI,kBAAkB,CAAC;IAErD;;OAEG;aACa,QAAQ,IAAI,MAAM;CACrC;AAED,qBAAa,qBAAqB;IAE9B,OAAO,CAAC,qBAAqB,CAAuB;IACpD,OAAO,CAAC,cAAc,CAAqB;gBAExB,OAAO,EAAE,oBAAoB;IAYhD;;OAEG;IACH,IAAW,IAAI,IAAI,MAAM,CAExB;IAED;;;OAGG;IACH,IAAW,aAAa,IAAI,OAAO,CAElC;IAED;;;OAGG;IACH,IAAW,eAAe,IAAI,OAAO,CAEpC;IAED;;;;OAIG;IACH,IAAW,WAAW,IAAI,MAAM,CAE/B;IAED;;OAEG;IACH,IAAW,aAAa,IAAI,WAAW,CAEtC;IAED;;;OAGG;IACH,IAAW,UAAU,IAAI,kBAAkB,CAE1C;IAED;;OAEG;IACI,QAAQ,IAAI,MAAM;CAG5B","file":"ConnectionMessage.d.ts","sourcesContent":["//\r\n// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\r\n//\r\n\r\n// eslint-disable-next-line max-classes-per-file\r\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\r\nimport {\r\n    ConnectionMessage as IntConnectionMessage,\r\n    MessageType\r\n} from \"../common/Exports\";\r\nimport {\r\n    PropertyCollection\r\n} from \"./PropertyCollection\";\r\nimport { PropertyId } from \"./PropertyId\";\r\n\r\n/**\r\n * ConnectionMessage represents implementation specific messages sent to and received from\r\n * the speech service. These messages are provided for debugging purposes and should not\r\n * be used for production use cases with the Azure Cognitive Services Speech Service.\r\n * Messages sent to and received from the Speech Service are subject to change without\r\n * notice. This includes message contents, headers, payloads, ordering, etc.\r\n * Added in version 1.11.0.\r\n */\r\nexport abstract class ConnectionMessage {\r\n    /**\r\n     * The message path.\r\n     */\r\n    public abstract get path(): string;\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a text message.\r\n     * See also IsBinaryMessage().\r\n     */\r\n    public abstract get isTextMessage(): boolean;\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a binary message.\r\n     * See also GetBinaryMessage().\r\n     */\r\n    public abstract get isBinaryMessage(): boolean;\r\n\r\n    /**\r\n     * Gets the text message payload. Typically the text message content-type is\r\n     * application/json. To determine other content-types use\r\n     * Properties.GetProperty(\"Content-Type\").\r\n     */\r\n    public abstract get TextMessage(): string;\r\n\r\n    /**\r\n     * Gets the binary message payload.\r\n     */\r\n    public abstract get binaryMessage(): ArrayBuffer;\r\n\r\n    /**\r\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\r\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\r\n     */\r\n    public abstract get properties(): PropertyCollection;\r\n\r\n    /**\r\n     * Returns a string that represents the connection message.\r\n     */\r\n    public abstract toString(): string;\r\n}\r\n\r\nexport class ConnectionMessageImpl {\r\n\r\n    private privConnectionMessage: IntConnectionMessage;\r\n    private privProperties: PropertyCollection;\r\n\r\n    public constructor(message: IntConnectionMessage) {\r\n        this.privConnectionMessage = message;\r\n        this.privProperties = new PropertyCollection();\r\n        if (!!this.privConnectionMessage.headers[HeaderNames.ConnectionId]) {\r\n            this.privProperties.setProperty(PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames.ConnectionId]);\r\n        }\r\n\r\n        Object.keys(this.privConnectionMessage.headers).forEach((header: string): void => {\r\n            this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The message path.\r\n     */\r\n    public get path(): string {\r\n        return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((key: string): boolean => key.toLowerCase() === \"path\".toLowerCase())];\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a text message.\r\n     * See also IsBinaryMessage().\r\n     */\r\n    public get isTextMessage(): boolean {\r\n        return this.privConnectionMessage.messageType === MessageType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a binary message.\r\n     * See also GetBinaryMessage().\r\n     */\r\n    public get isBinaryMessage(): boolean {\r\n        return this.privConnectionMessage.messageType === MessageType.Binary;\r\n    }\r\n\r\n    /**\r\n     * Gets the text message payload. Typically the text message content-type is\r\n     * application/json. To determine other content-types use\r\n     * Properties.GetProperty(\"Content-Type\").\r\n     */\r\n    public get TextMessage(): string {\r\n        return this.privConnectionMessage.textBody;\r\n    }\r\n\r\n    /**\r\n     * Gets the binary message payload.\r\n     */\r\n    public get binaryMessage(): ArrayBuffer {\r\n        return this.privConnectionMessage.binaryBody;\r\n    }\r\n\r\n    /**\r\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\r\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\r\n     */\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    /**\r\n     * Returns a string that represents the connection message.\r\n     */\r\n    public toString(): string {\r\n        return \"\";\r\n    }\r\n}\r\n"]}